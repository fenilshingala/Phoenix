#version 430 core

#define MAX_KERNELSIZE 256 
#define THREADS 256

layout (local_size_x = 1, local_size_y = THREADS, local_size_z = 1) in; // Declares thread group size

uniform BlurKernel { 
  float m_weights[THREADS];
  int m_kernelSize;
  int m_widthResolution;
  int m_heightResolution;
} blurKernel; 

// single channel 16bit/32bit float images
layout(binding =0 , rgba32f) uniform readonly  image2D  input_image;   
layout(binding =1 , rgba32f) uniform writeonly image2D  output_image;

shared vec4 shared_data[THREADS + MAX_KERNELSIZE]; 

void main() {
	ivec2 gpos = ivec2(gl_GlobalInvocationID.xy); 
	
	ivec2 leftLimit = gpos + ivec2(0, -blurKernel.m_kernelSize);
	
	if(leftLimit.y < 0) {
		leftLimit.y = 0;
	}
	
	ivec2 rightLimit = gpos + ivec2(0, THREADS - blurKernel.m_kernelSize);
	if(rightLimit.y > blurKernel.m_heightResolution - 1) {
		rightLimit.y = blurKernel.m_heightResolution - 1;
	}	
		
	uint local_id =  gl_LocalInvocationID.y;
	
	shared_data[local_id] = imageLoad(input_image, leftLimit);	
	
	if(local_id < blurKernel.m_kernelSize*2) {
		shared_data[local_id + THREADS] =  imageLoad(input_image, rightLimit); 
	}
	
	//sync
	barrier(); 	
	
	vec4 blurColor = vec4(0);	

	for (int i = -blurKernel.m_kernelSize; i <= blurKernel.m_kernelSize; ++i) {
		blurColor +=  blurKernel.m_weights[blurKernel.m_kernelSize+i]*shared_data[blurKernel.m_kernelSize + local_id + i];			
    }

	imageStore(output_image, gpos, blurColor); // Write to destination image
}
