#version 430 core

#define MAX_KERNELSIZE 256 
#define THREADS 256

layout (local_size_x = THREADS, local_size_y = 1, local_size_z = 1) in;

uniform BlurKernel { 
  float m_weights[THREADS];
  int m_kernelSize;
  int m_widthResolution;
  int m_heightResolution;
} blurKernel; 

// single channel 16bit/32bit float images
layout(binding = 0, rgba32f) uniform readonly  image2D  input_image;   
layout(binding = 1, rgba32f) uniform writeonly image2D  output_image;

shared vec4 shared_data[THREADS+MAX_KERNELSIZE]; 

void main() {
	ivec2 gpos = ivec2(gl_GlobalInvocationID.xy);
	
	ivec2 localPos = gpos + ivec2(THREADS, 0);
	
	ivec2 leftLimit = gpos + ivec2(-blurKernel.m_kernelSize, 0);
	if(leftLimit.x < 0) {
		leftLimit.x = 0;
	}
 
	ivec2 rightLimit = gpos + ivec2(THREADS - blurKernel.m_kernelSize, 0);
	if(rightLimit.x > blurKernel.m_widthResolution - 1) {
		rightLimit.x = blurKernel.m_widthResolution - 1;
	}	
		
	uint local_id = gl_LocalInvocationID.x;
	
	shared_data[local_id] = imageLoad(input_image, leftLimit);	
	
	if(local_id < blurKernel.m_kernelSize*2) {
		shared_data[local_id + THREADS] =  imageLoad(input_image, rightLimit); 
	}
	
	barrier(); 
	
	vec4 blurColor = vec4(0);
	
	for (int i = -blurKernel.m_kernelSize; i <= blurKernel.m_kernelSize; ++i) {
        blurColor +=  blurKernel.m_weights[blurKernel.m_kernelSize+i]*shared_data[blurKernel.m_kernelSize+local_id + i];
    }

	imageStore(output_image, gpos, blurColor); 
}